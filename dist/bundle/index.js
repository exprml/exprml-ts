(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@bufbuild/protobuf/codegenv1'), require('@bufbuild/protobuf'), require('yaml')) :
    typeof define === 'function' && define.amd ? define(['exports', '@bufbuild/protobuf/codegenv1', '@bufbuild/protobuf', 'yaml'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.eyamluate = {}, global.codegenv1, global.protobuf, global.YAML));
})(this, (function (exports, codegenv1, protobuf, YAML) { 'use strict';

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/value.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/value.proto.
     */
    const file_exprml_v1_value = /*@__PURE__*/ codegenv1.fileDesc("ChVleHBybWwvdjEvdmFsdWUucHJvdG8SCWV4cHJtbC52MSKqAgoFVmFsdWUSIwoEdHlwZRgBIAEoDjIVLmV4cHJtbC52MS5WYWx1ZS5UeXBlEgwKBGJvb2wYAiABKAgSCwoDbnVtGAMgASgBEgsKA3N0chgEIAEoCRIdCgNhcnIYBSADKAsyEC5leHBybWwudjEuVmFsdWUSJgoDb2JqGAYgAygLMhkuZXhwcm1sLnYxLlZhbHVlLk9iakVudHJ5GjwKCE9iakVudHJ5EgsKA2tleRgBIAEoCRIfCgV2YWx1ZRgCIAEoCzIQLmV4cHJtbC52MS5WYWx1ZToCOAEiTwoEVHlwZRIPCgtVTlNQRUNJRklFRBAAEggKBE5VTEwQARIICgRCT09MEAISBwoDTlVNEAMSBwoDU1RSEAQSBwoDQVJSEAUSBwoDT0JKEAZCYAoNY29tLmV4cHJtbC52MUIKVmFsdWVQcm90b1ABogIDRVhYqgIJRXhwcm1sLlYxygIJRXhwcm1sXFYx4gIVRXhwcm1sXFYxXEdQQk1ldGFkYXRh6gIKRXhwcm1sOjpWMWIGcHJvdG8z");
    /**
     * Describes the message exprml.v1.Value.
     * Use `create(ValueSchema)` to create a new message.
     */
    const ValueSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_value, 0);
    /**
     * Type of a JSON value.
     *
     * @generated from enum exprml.v1.Value.Type
     */
    exports.Value_Type = void 0;
    (function (Value_Type) {
        /**
         * Unspecified.
         *
         * @generated from enum value: UNSPECIFIED = 0;
         */
        Value_Type[Value_Type["UNSPECIFIED"] = 0] = "UNSPECIFIED";
        /**
         * Null type.
         *
         * @generated from enum value: NULL = 1;
         */
        Value_Type[Value_Type["NULL"] = 1] = "NULL";
        /**
         * Boolean type.
         *
         * @generated from enum value: BOOL = 2;
         */
        Value_Type[Value_Type["BOOL"] = 2] = "BOOL";
        /**
         * Number type.
         *
         * @generated from enum value: NUM = 3;
         */
        Value_Type[Value_Type["NUM"] = 3] = "NUM";
        /**
         * String type.
         *
         * @generated from enum value: STR = 4;
         */
        Value_Type[Value_Type["STR"] = 4] = "STR";
        /**
         * Array type.
         *
         * @generated from enum value: ARR = 5;
         */
        Value_Type[Value_Type["ARR"] = 5] = "ARR";
        /**
         * Object type.
         *
         * @generated from enum value: OBJ = 6;
         */
        Value_Type[Value_Type["OBJ"] = 6] = "OBJ";
    })(exports.Value_Type || (exports.Value_Type = {}));
    /**
     * Describes the enum exprml.v1.Value.Type.
     */
    const Value_TypeSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_value, 0, 0);

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/encoder.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/encoder.proto.
     */
    const file_exprml_v1_encoder = /*@__PURE__*/ codegenv1.fileDesc("ChdleHBybWwvdjEvZW5jb2Rlci5wcm90bxIJZXhwcm1sLnYxInsKC0VuY29kZUlucHV0Ei0KBmZvcm1hdBgBIAEoDjIdLmV4cHJtbC52MS5FbmNvZGVJbnB1dC5Gb3JtYXQSHwoFdmFsdWUYAyABKAsyEC5leHBybWwudjEuVmFsdWUiHAoGRm9ybWF0EggKBFlBTUwQABIICgRKU09OEAEiRwoMRW5jb2RlT3V0cHV0EhAKCGlzX2Vycm9yGAEgASgIEhUKDWVycm9yX21lc3NhZ2UYAiABKAkSDgoGcmVzdWx0GAMgASgJMkYKB0VuY29kZXISOwoGRW5jb2RlEhYuZXhwcm1sLnYxLkVuY29kZUlucHV0GhcuZXhwcm1sLnYxLkVuY29kZU91dHB1dCIAQmIKDWNvbS5leHBybWwudjFCDEVuY29kZXJQcm90b1ABogIDRVhYqgIJRXhwcm1sLlYxygIJRXhwcm1sXFYx4gIVRXhwcm1sXFYxXEdQQk1ldGFkYXRh6gIKRXhwcm1sOjpWMWIGcHJvdG8z", [file_exprml_v1_value]);
    /**
     * Describes the message exprml.v1.EncodeInput.
     * Use `create(EncodeInputSchema)` to create a new message.
     */
    const EncodeInputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_encoder, 0);
    /**
     * Format of the output string.
     *
     * @generated from enum exprml.v1.EncodeInput.Format
     */
    exports.EncodeInput_Format = void 0;
    (function (EncodeInput_Format) {
        /**
         * YAML format.
         *
         * @generated from enum value: YAML = 0;
         */
        EncodeInput_Format[EncodeInput_Format["YAML"] = 0] = "YAML";
        /**
         * JSON format.
         *
         * @generated from enum value: JSON = 1;
         */
        EncodeInput_Format[EncodeInput_Format["JSON"] = 1] = "JSON";
    })(exports.EncodeInput_Format || (exports.EncodeInput_Format = {}));
    /**
     * Describes the enum exprml.v1.EncodeInput.Format.
     */
    const EncodeInput_FormatSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_encoder, 0, 0);
    /**
     * Describes the message exprml.v1.EncodeOutput.
     * Use `create(EncodeOutputSchema)` to create a new message.
     */
    const EncodeOutputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_encoder, 1);

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/decoder.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/decoder.proto.
     */
    const file_exprml_v1_decoder = /*@__PURE__*/ codegenv1.fileDesc("ChdleHBybWwvdjEvZGVjb2Rlci5wcm90bxIJZXhwcm1sLnYxIhsKC0RlY29kZUlucHV0EgwKBHlhbWwYASABKAkiWAoMRGVjb2RlT3V0cHV0EhAKCGlzX2Vycm9yGAEgASgIEhUKDWVycm9yX21lc3NhZ2UYAiABKAkSHwoFdmFsdWUYAyABKAsyEC5leHBybWwudjEuVmFsdWUyRgoHRGVjb2RlchI7CgZEZWNvZGUSFi5leHBybWwudjEuRGVjb2RlSW5wdXQaFy5leHBybWwudjEuRGVjb2RlT3V0cHV0IgBCYgoNY29tLmV4cHJtbC52MUIMRGVjb2RlclByb3RvUAGiAgNFWFiqAglFeHBybWwuVjHKAglFeHBybWxcVjHiAhVFeHBybWxcVjFcR1BCTWV0YWRhdGHqAgpFeHBybWw6OlYxYgZwcm90bzM", [file_exprml_v1_value]);
    /**
     * Describes the message exprml.v1.DecodeInput.
     * Use `create(DecodeInputSchema)` to create a new message.
     */
    const DecodeInputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_decoder, 0);
    /**
     * Describes the message exprml.v1.DecodeOutput.
     * Use `create(DecodeOutputSchema)` to create a new message.
     */
    const DecodeOutputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_decoder, 1);

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/expr.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/expr.proto.
     */
    const file_exprml_v1_expr = /*@__PURE__*/ codegenv1.fileDesc("ChRleHBybWwvdjEvZXhwci5wcm90bxIJZXhwcm1sLnYxIp0GCgRFeHByEiIKBHBhdGgYASABKAsyFC5leHBybWwudjEuRXhwci5QYXRoEh8KBXZhbHVlGAIgASgLMhAuZXhwcm1sLnYxLlZhbHVlEiIKBGtpbmQYAyABKA4yFC5leHBybWwudjEuRXhwci5LaW5kEh0KBGV2YWwYCiABKAsyDy5leHBybWwudjEuRXZhbBIhCgZzY2FsYXIYCyABKAsyES5leHBybWwudjEuU2NhbGFyEhsKA3JlZhgMIAEoCzIOLmV4cHJtbC52MS5SZWYSGwoDb2JqGA0gASgLMg4uZXhwcm1sLnYxLk9iahIbCgNhcnIYDiABKAsyDi5leHBybWwudjEuQXJyEh0KBGpzb24YDyABKAsyDy5leHBybWwudjEuSnNvbhIdCgRpdGVyGBAgASgLMg8uZXhwcm1sLnYxLkl0ZXISHQoEZWxlbRgRIAEoCzIPLmV4cHJtbC52MS5FbGVtEh0KBGNhbGwYEiABKAsyDy5leHBybWwudjEuQ2FsbBIfCgVjYXNlcxgTIAEoCzIQLmV4cHJtbC52MS5DYXNlcxIkCghvcF91bmFyeRgUIAEoCzISLmV4cHJtbC52MS5PcFVuYXJ5EiYKCW9wX2JpbmFyeRgVIAEoCzITLmV4cHJtbC52MS5PcEJpbmFyeRIqCgtvcF92YXJpYWRpYxgWIAEoCzIVLmV4cHJtbC52MS5PcFZhcmlhZGljGlAKBFBhdGgSJQoDcG9zGAEgAygLMhguZXhwcm1sLnYxLkV4cHIuUGF0aC5Qb3MaIQoDUG9zEg0KBWluZGV4GAEgASgDEgsKA2tleRgCIAEoCSKpAQoES2luZBIPCgtVTlNQRUNJRklFRBAAEggKBEVWQUwQChIKCgZTQ0FMQVIQCxIHCgNSRUYQDBIHCgNPQkoQDRIHCgNBUlIQDhIICgRKU09OEA8SCAoESVRFUhAQEggKBEVMRU0QERIICgRDQUxMEBISCQoFQ0FTRVMQExIMCghPUF9VTkFSWRAUEg0KCU9QX0JJTkFSWRAVEg8KC09QX1ZBUklBRElDEBYimgEKBEV2YWwSHQoEZXZhbBgBIAEoCzIPLmV4cHJtbC52MS5FeHByEikKBXdoZXJlGAIgAygLMhouZXhwcm1sLnYxLkV2YWwuRGVmaW5pdGlvbhpICgpEZWZpbml0aW9uEg0KBWlkZW50GAEgASgJEgwKBGFyZ3MYAiADKAkSHQoEYm9keRgDIAEoCzIPLmV4cHJtbC52MS5FeHByIioKBlNjYWxhchIgCgZzY2FsYXIYASABKAsyEC5leHBybWwudjEuVmFsdWUiFAoDUmVmEg0KBWlkZW50GAEgASgJImgKA09iahIkCgNvYmoYASADKAsyFy5leHBybWwudjEuT2JqLk9iakVudHJ5GjsKCE9iakVudHJ5EgsKA2tleRgBIAEoCRIeCgV2YWx1ZRgCIAEoCzIPLmV4cHJtbC52MS5FeHByOgI4ASIjCgNBcnISHAoDYXJyGAEgAygLMg8uZXhwcm1sLnYxLkV4cHIiJgoESnNvbhIeCgRqc29uGAEgASgLMhAuZXhwcm1sLnYxLlZhbHVlIoUBCgRJdGVyEhEKCXBvc19pZGVudBgBIAEoCRISCgplbGVtX2lkZW50GAIgASgJEhwKA2NvbBgDIAEoCzIPLmV4cHJtbC52MS5FeHByEhsKAmRvGAQgASgLMg8uZXhwcm1sLnYxLkV4cHISGwoCaWYYBSABKAsyDy5leHBybWwudjEuRXhwciJDCgRFbGVtEhwKA2dldBgBIAEoCzIPLmV4cHJtbC52MS5FeHByEh0KBGZyb20YAiABKAsyDy5leHBybWwudjEuRXhwciJ8CgRDYWxsEg0KBWlkZW50GAEgASgJEicKBGFyZ3MYAiADKAsyGS5leHBybWwudjEuQ2FsbC5BcmdzRW50cnkaPAoJQXJnc0VudHJ5EgsKA2tleRgBIAEoCRIeCgV2YWx1ZRgCIAEoCzIPLmV4cHJtbC52MS5FeHByOgI4ASKtAQoFQ2FzZXMSJAoFY2FzZXMYASADKAsyFS5leHBybWwudjEuQ2FzZXMuQ2FzZRp+CgRDYXNlEhQKDGlzX290aGVyd2lzZRgBIAEoCBIdCgR3aGVuGAIgASgLMg8uZXhwcm1sLnYxLkV4cHISHQoEdGhlbhgDIAEoCzIPLmV4cHJtbC52MS5FeHByEiIKCW90aGVyd2lzZRgEIAEoCzIPLmV4cHJtbC52MS5FeHByIqEBCgdPcFVuYXJ5EiEKAm9wGAEgASgOMhUuZXhwcm1sLnYxLk9wVW5hcnkuT3ASIAoHb3BlcmFuZBgCIAEoCzIPLmV4cHJtbC52MS5FeHByIlEKAk9wEg8KC1VOU1BFQ0lGSUVEEAASBwoDTEVOEAESBwoDTk9UEAISCAoERkxBVBADEgkKBUZMT09SEAQSCAoEQ0VJTBAFEgkKBUFCT1JUEAYiyQEKCE9wQmluYXJ5EiIKAm9wGAEgASgOMhYuZXhwcm1sLnYxLk9wQmluYXJ5Lk9wEh0KBGxlZnQYAiABKAsyDy5leHBybWwudjEuRXhwchIeCgVyaWdodBgDIAEoCzIPLmV4cHJtbC52MS5FeHByIloKAk9wEg8KC1VOU1BFQ0lGSUVEEAASBwoDU1VCEAESBwoDRElWEAISBgoCRVEQAxIHCgNORVEQBBIGCgJMVBAFEgcKA0xURRAGEgYKAkdUEAcSBwoDR1RFEAgitQEKCk9wVmFyaWFkaWMSJAoCb3AYASABKA4yGC5leHBybWwudjEuT3BWYXJpYWRpYy5PcBIhCghvcGVyYW5kcxgCIAMoCzIPLmV4cHJtbC52MS5FeHByIl4KAk9wEg8KC1VOU1BFQ0lGSUVEEAASBwoDQUREEAESBwoDTVVMEAISBwoDQU5EEAMSBgoCT1IQBBIHCgNDQVQQBRIHCgNNSU4QBhIHCgNNQVgQBxIJCgVNRVJHRRAIQl8KDWNvbS5leHBybWwudjFCCUV4cHJQcm90b1ABogIDRVhYqgIJRXhwcm1sLlYxygIJRXhwcm1sXFYx4gIVRXhwcm1sXFYxXEdQQk1ldGFkYXRh6gIKRXhwcm1sOjpWMWIGcHJvdG8z", [file_exprml_v1_value]);
    /**
     * Describes the message exprml.v1.Expr.
     * Use `create(ExprSchema)` to create a new message.
     */
    const ExprSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 0);
    /**
     * Describes the message exprml.v1.Expr.Path.
     * Use `create(Expr_PathSchema)` to create a new message.
     */
    const Expr_PathSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 0, 0);
    /**
     * Describes the message exprml.v1.Expr.Path.Pos.
     * Use `create(Expr_Path_PosSchema)` to create a new message.
     */
    const Expr_Path_PosSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 0, 0, 0);
    /**
     * Kind is the kind of the Node.
     *
     * @generated from enum exprml.v1.Expr.Kind
     */
    exports.Expr_Kind = void 0;
    (function (Expr_Kind) {
        /**
         * Unspecified.
         *
         * @generated from enum value: UNSPECIFIED = 0;
         */
        Expr_Kind[Expr_Kind["UNSPECIFIED"] = 0] = "UNSPECIFIED";
        /**
         * Eval kind.
         *
         * @generated from enum value: EVAL = 10;
         */
        Expr_Kind[Expr_Kind["EVAL"] = 10] = "EVAL";
        /**
         * Scalar kind.
         *
         * @generated from enum value: SCALAR = 11;
         */
        Expr_Kind[Expr_Kind["SCALAR"] = 11] = "SCALAR";
        /**
         * Ref kind.
         *
         * @generated from enum value: REF = 12;
         */
        Expr_Kind[Expr_Kind["REF"] = 12] = "REF";
        /**
         * Obj kind.
         *
         * @generated from enum value: OBJ = 13;
         */
        Expr_Kind[Expr_Kind["OBJ"] = 13] = "OBJ";
        /**
         * Arr kind.
         *
         * @generated from enum value: ARR = 14;
         */
        Expr_Kind[Expr_Kind["ARR"] = 14] = "ARR";
        /**
         * Json kind.
         *
         * @generated from enum value: JSON = 15;
         */
        Expr_Kind[Expr_Kind["JSON"] = 15] = "JSON";
        /**
         * Iter kind.
         *
         * @generated from enum value: ITER = 16;
         */
        Expr_Kind[Expr_Kind["ITER"] = 16] = "ITER";
        /**
         * Elem kind.
         *
         * @generated from enum value: ELEM = 17;
         */
        Expr_Kind[Expr_Kind["ELEM"] = 17] = "ELEM";
        /**
         * Call kind.
         *
         * @generated from enum value: CALL = 18;
         */
        Expr_Kind[Expr_Kind["CALL"] = 18] = "CALL";
        /**
         * Cases kind.
         *
         * @generated from enum value: CASES = 19;
         */
        Expr_Kind[Expr_Kind["CASES"] = 19] = "CASES";
        /**
         * OpUnary kind.
         *
         * @generated from enum value: OP_UNARY = 20;
         */
        Expr_Kind[Expr_Kind["OP_UNARY"] = 20] = "OP_UNARY";
        /**
         * OpBinary kind.
         *
         * @generated from enum value: OP_BINARY = 21;
         */
        Expr_Kind[Expr_Kind["OP_BINARY"] = 21] = "OP_BINARY";
        /**
         * OpVariadic kind.
         *
         * @generated from enum value: OP_VARIADIC = 22;
         */
        Expr_Kind[Expr_Kind["OP_VARIADIC"] = 22] = "OP_VARIADIC";
    })(exports.Expr_Kind || (exports.Expr_Kind = {}));
    /**
     * Describes the enum exprml.v1.Expr.Kind.
     */
    const Expr_KindSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_expr, 0, 0);
    /**
     * Describes the message exprml.v1.Eval.
     * Use `create(EvalSchema)` to create a new message.
     */
    const EvalSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 1);
    /**
     * Describes the message exprml.v1.Eval.Definition.
     * Use `create(Eval_DefinitionSchema)` to create a new message.
     */
    const Eval_DefinitionSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 1, 0);
    /**
     * Describes the message exprml.v1.Scalar.
     * Use `create(ScalarSchema)` to create a new message.
     */
    const ScalarSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 2);
    /**
     * Describes the message exprml.v1.Ref.
     * Use `create(RefSchema)` to create a new message.
     */
    const RefSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 3);
    /**
     * Describes the message exprml.v1.Obj.
     * Use `create(ObjSchema)` to create a new message.
     */
    const ObjSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 4);
    /**
     * Describes the message exprml.v1.Arr.
     * Use `create(ArrSchema)` to create a new message.
     */
    const ArrSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 5);
    /**
     * Describes the message exprml.v1.Json.
     * Use `create(JsonSchema)` to create a new message.
     */
    const JsonSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 6);
    /**
     * Describes the message exprml.v1.Iter.
     * Use `create(IterSchema)` to create a new message.
     */
    const IterSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 7);
    /**
     * Describes the message exprml.v1.Elem.
     * Use `create(ElemSchema)` to create a new message.
     */
    const ElemSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 8);
    /**
     * Describes the message exprml.v1.Call.
     * Use `create(CallSchema)` to create a new message.
     */
    const CallSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 9);
    /**
     * Describes the message exprml.v1.Cases.
     * Use `create(CasesSchema)` to create a new message.
     */
    const CasesSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 10);
    /**
     * Describes the message exprml.v1.Cases.Case.
     * Use `create(Cases_CaseSchema)` to create a new message.
     */
    const Cases_CaseSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 10, 0);
    /**
     * Describes the message exprml.v1.OpUnary.
     * Use `create(OpUnarySchema)` to create a new message.
     */
    const OpUnarySchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 11);
    /**
     * Op is a operator.
     *
     * @generated from enum exprml.v1.OpUnary.Op
     */
    exports.OpUnary_Op = void 0;
    (function (OpUnary_Op) {
        /**
         * Unspecified.
         *
         * @generated from enum value: UNSPECIFIED = 0;
         */
        OpUnary_Op[OpUnary_Op["UNSPECIFIED"] = 0] = "UNSPECIFIED";
        /**
         * Len operator.
         *
         * @generated from enum value: LEN = 1;
         */
        OpUnary_Op[OpUnary_Op["LEN"] = 1] = "LEN";
        /**
         * Not operator.
         *
         * @generated from enum value: NOT = 2;
         */
        OpUnary_Op[OpUnary_Op["NOT"] = 2] = "NOT";
        /**
         * Flat operator.
         *
         * @generated from enum value: FLAT = 3;
         */
        OpUnary_Op[OpUnary_Op["FLAT"] = 3] = "FLAT";
        /**
         * Floor operator.
         *
         * @generated from enum value: FLOOR = 4;
         */
        OpUnary_Op[OpUnary_Op["FLOOR"] = 4] = "FLOOR";
        /**
         * Ceil operator.
         *
         * @generated from enum value: CEIL = 5;
         */
        OpUnary_Op[OpUnary_Op["CEIL"] = 5] = "CEIL";
        /**
         * Abort operator.
         *
         * @generated from enum value: ABORT = 6;
         */
        OpUnary_Op[OpUnary_Op["ABORT"] = 6] = "ABORT";
    })(exports.OpUnary_Op || (exports.OpUnary_Op = {}));
    /**
     * Describes the enum exprml.v1.OpUnary.Op.
     */
    const OpUnary_OpSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_expr, 11, 0);
    /**
     * Describes the message exprml.v1.OpBinary.
     * Use `create(OpBinarySchema)` to create a new message.
     */
    const OpBinarySchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 12);
    /**
     * Op is a operator.
     *
     * @generated from enum exprml.v1.OpBinary.Op
     */
    exports.OpBinary_Op = void 0;
    (function (OpBinary_Op) {
        /**
         * Unspecified.
         *
         * @generated from enum value: UNSPECIFIED = 0;
         */
        OpBinary_Op[OpBinary_Op["UNSPECIFIED"] = 0] = "UNSPECIFIED";
        /**
         * Sub operator.
         *
         * @generated from enum value: SUB = 1;
         */
        OpBinary_Op[OpBinary_Op["SUB"] = 1] = "SUB";
        /**
         * Div operator.
         *
         * @generated from enum value: DIV = 2;
         */
        OpBinary_Op[OpBinary_Op["DIV"] = 2] = "DIV";
        /**
         * Eq operator.
         *
         * @generated from enum value: EQ = 3;
         */
        OpBinary_Op[OpBinary_Op["EQ"] = 3] = "EQ";
        /**
         * Neq operator.
         *
         * @generated from enum value: NEQ = 4;
         */
        OpBinary_Op[OpBinary_Op["NEQ"] = 4] = "NEQ";
        /**
         * Lt operator.
         *
         * @generated from enum value: LT = 5;
         */
        OpBinary_Op[OpBinary_Op["LT"] = 5] = "LT";
        /**
         * Lte operator.
         *
         * @generated from enum value: LTE = 6;
         */
        OpBinary_Op[OpBinary_Op["LTE"] = 6] = "LTE";
        /**
         * Gt operator.
         *
         * @generated from enum value: GT = 7;
         */
        OpBinary_Op[OpBinary_Op["GT"] = 7] = "GT";
        /**
         * Gte operator.
         *
         * @generated from enum value: GTE = 8;
         */
        OpBinary_Op[OpBinary_Op["GTE"] = 8] = "GTE";
    })(exports.OpBinary_Op || (exports.OpBinary_Op = {}));
    /**
     * Describes the enum exprml.v1.OpBinary.Op.
     */
    const OpBinary_OpSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_expr, 12, 0);
    /**
     * Describes the message exprml.v1.OpVariadic.
     * Use `create(OpVariadicSchema)` to create a new message.
     */
    const OpVariadicSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_expr, 13);
    /**
     * Op is a operator.
     *
     * @generated from enum exprml.v1.OpVariadic.Op
     */
    exports.OpVariadic_Op = void 0;
    (function (OpVariadic_Op) {
        /**
         * Unspecified.
         *
         * @generated from enum value: UNSPECIFIED = 0;
         */
        OpVariadic_Op[OpVariadic_Op["UNSPECIFIED"] = 0] = "UNSPECIFIED";
        /**
         * Add operator.
         *
         * @generated from enum value: ADD = 1;
         */
        OpVariadic_Op[OpVariadic_Op["ADD"] = 1] = "ADD";
        /**
         * Mul operator.
         *
         * @generated from enum value: MUL = 2;
         */
        OpVariadic_Op[OpVariadic_Op["MUL"] = 2] = "MUL";
        /**
         * And operator.
         *
         * @generated from enum value: AND = 3;
         */
        OpVariadic_Op[OpVariadic_Op["AND"] = 3] = "AND";
        /**
         * Or operator.
         *
         * @generated from enum value: OR = 4;
         */
        OpVariadic_Op[OpVariadic_Op["OR"] = 4] = "OR";
        /**
         * Cat operator.
         *
         * @generated from enum value: CAT = 5;
         */
        OpVariadic_Op[OpVariadic_Op["CAT"] = 5] = "CAT";
        /**
         * Min operator.
         *
         * @generated from enum value: MIN = 6;
         */
        OpVariadic_Op[OpVariadic_Op["MIN"] = 6] = "MIN";
        /**
         * Max operator.
         *
         * @generated from enum value: MAX = 7;
         */
        OpVariadic_Op[OpVariadic_Op["MAX"] = 7] = "MAX";
        /**
         * Merge operator.
         *
         * @generated from enum value: MERGE = 8;
         */
        OpVariadic_Op[OpVariadic_Op["MERGE"] = 8] = "MERGE";
    })(exports.OpVariadic_Op || (exports.OpVariadic_Op = {}));
    /**
     * Describes the enum exprml.v1.OpVariadic.Op.
     */
    const OpVariadic_OpSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_expr, 13, 0);

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/evaluator.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/evaluator.proto.
     */
    const file_exprml_v1_evaluator = /*@__PURE__*/ codegenv1.fileDesc("ChlleHBybWwvdjEvZXZhbHVhdG9yLnByb3RvEglleHBybWwudjEiWAoIRGVmU3RhY2sSIwoGcGFyZW50GAEgASgLMhMuZXhwcm1sLnYxLkRlZlN0YWNrEicKA2RlZhgCIAEoCzIaLmV4cHJtbC52MS5FdmFsLkRlZmluaXRpb24iVgoNRXZhbHVhdGVJbnB1dBImCglkZWZfc3RhY2sYASABKAsyEy5leHBybWwudjEuRGVmU3RhY2sSHQoEZXhwchgCIAEoCzIPLmV4cHJtbC52MS5FeHByIoUDCg5FdmFsdWF0ZU91dHB1dBIwCgZzdGF0dXMYASABKA4yIC5leHBybWwudjEuRXZhbHVhdGVPdXRwdXQuU3RhdHVzEhUKDWVycm9yX21lc3NhZ2UYAiABKAkSKAoKZXJyb3JfcGF0aBgDIAEoCzIULmV4cHJtbC52MS5FeHByLlBhdGgSHwoFdmFsdWUYBCABKAsyEC5leHBybWwudjEuVmFsdWUi3gEKBlN0YXR1cxIGCgJPSxAAEhEKDUlOVkFMSURfSU5ERVgQZBIPCgtJTlZBTElEX0tFWRBlEhMKD1VORVhQRUNURURfVFlQRRBmEhUKEUFSR1VNRU5UX01JU01BVENIEGcSGAoUQ0FTRVNfTk9UX0VYSEFVU1RJVkUQaBIXChNSRUZFUkVOQ0VfTk9UX0ZPVU5EEGkSEgoOTk9UX0NPTVBBUkFCTEUQahIVChFOT1RfRklOSVRFX05VTUJFUhBrEgsKB0FCT1JURUQQbBIRCg1VTktOT1dOX0VSUk9SEG0y+gcKCUV2YWx1YXRvchJFCgxFdmFsdWF0ZUV4cHISGC5leHBybWwudjEuRXZhbHVhdGVJbnB1dBoZLmV4cHJtbC52MS5FdmFsdWF0ZU91dHB1dCIAEkUKDEV2YWx1YXRlRXZhbBIYLmV4cHJtbC52MS5FdmFsdWF0ZUlucHV0GhkuZXhwcm1sLnYxLkV2YWx1YXRlT3V0cHV0IgASRwoORXZhbHVhdGVTY2FsYXISGC5leHBybWwudjEuRXZhbHVhdGVJbnB1dBoZLmV4cHJtbC52MS5FdmFsdWF0ZU91dHB1dCIAEkQKC0V2YWx1YXRlUmVmEhguZXhwcm1sLnYxLkV2YWx1YXRlSW5wdXQaGS5leHBybWwudjEuRXZhbHVhdGVPdXRwdXQiABJECgtFdmFsdWF0ZU9iahIYLmV4cHJtbC52MS5FdmFsdWF0ZUlucHV0GhkuZXhwcm1sLnYxLkV2YWx1YXRlT3V0cHV0IgASRAoLRXZhbHVhdGVBcnISGC5leHBybWwudjEuRXZhbHVhdGVJbnB1dBoZLmV4cHJtbC52MS5FdmFsdWF0ZU91dHB1dCIAEkUKDEV2YWx1YXRlSnNvbhIYLmV4cHJtbC52MS5FdmFsdWF0ZUlucHV0GhkuZXhwcm1sLnYxLkV2YWx1YXRlT3V0cHV0IgASRQoMRXZhbHVhdGVJdGVyEhguZXhwcm1sLnYxLkV2YWx1YXRlSW5wdXQaGS5leHBybWwudjEuRXZhbHVhdGVPdXRwdXQiABJFCgxFdmFsdWF0ZUVsZW0SGC5leHBybWwudjEuRXZhbHVhdGVJbnB1dBoZLmV4cHJtbC52MS5FdmFsdWF0ZU91dHB1dCIAEkUKDEV2YWx1YXRlQ2FsbBIYLmV4cHJtbC52MS5FdmFsdWF0ZUlucHV0GhkuZXhwcm1sLnYxLkV2YWx1YXRlT3V0cHV0IgASRgoNRXZhbHVhdGVDYXNlcxIYLmV4cHJtbC52MS5FdmFsdWF0ZUlucHV0GhkuZXhwcm1sLnYxLkV2YWx1YXRlT3V0cHV0IgASSAoPRXZhbHVhdGVPcFVuYXJ5EhguZXhwcm1sLnYxLkV2YWx1YXRlSW5wdXQaGS5leHBybWwudjEuRXZhbHVhdGVPdXRwdXQiABJJChBFdmFsdWF0ZU9wQmluYXJ5EhguZXhwcm1sLnYxLkV2YWx1YXRlSW5wdXQaGS5leHBybWwudjEuRXZhbHVhdGVPdXRwdXQiABJLChJFdmFsdWF0ZU9wVmFyaWFkaWMSGC5leHBybWwudjEuRXZhbHVhdGVJbnB1dBoZLmV4cHJtbC52MS5FdmFsdWF0ZU91dHB1dCIAQmQKDWNvbS5leHBybWwudjFCDkV2YWx1YXRvclByb3RvUAGiAgNFWFiqAglFeHBybWwuVjHKAglFeHBybWxcVjHiAhVFeHBybWxcVjFcR1BCTWV0YWRhdGHqAgpFeHBybWw6OlYxYgZwcm90bzM", [file_exprml_v1_expr, file_exprml_v1_value]);
    /**
     * Describes the message exprml.v1.DefStack.
     * Use `create(DefStackSchema)` to create a new message.
     */
    const DefStackSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_evaluator, 0);
    /**
     * Describes the message exprml.v1.EvaluateInput.
     * Use `create(EvaluateInputSchema)` to create a new message.
     */
    const EvaluateInputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_evaluator, 1);
    /**
     * Describes the message exprml.v1.EvaluateOutput.
     * Use `create(EvaluateOutputSchema)` to create a new message.
     */
    const EvaluateOutputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_evaluator, 2);
    /**
     * Status of the evaluation.
     *
     * @generated from enum exprml.v1.EvaluateOutput.Status
     */
    exports.EvaluateOutput_Status = void 0;
    (function (EvaluateOutput_Status) {
        /**
         * Evaluation was successful.
         *
         * @generated from enum value: OK = 0;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["OK"] = 0] = "OK";
        /**
         * Index is invalid.
         *
         * @generated from enum value: INVALID_INDEX = 100;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["INVALID_INDEX"] = 100] = "INVALID_INDEX";
        /**
         * Key is invalid.
         *
         * @generated from enum value: INVALID_KEY = 101;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["INVALID_KEY"] = 101] = "INVALID_KEY";
        /**
         * Type is unexpected.
         *
         * @generated from enum value: UNEXPECTED_TYPE = 102;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["UNEXPECTED_TYPE"] = 102] = "UNEXPECTED_TYPE";
        /**
         * Argument mismatch.
         *
         * @generated from enum value: ARGUMENT_MISMATCH = 103;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["ARGUMENT_MISMATCH"] = 103] = "ARGUMENT_MISMATCH";
        /**
         * Cases are not exhaustive.
         *
         * @generated from enum value: CASES_NOT_EXHAUSTIVE = 104;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["CASES_NOT_EXHAUSTIVE"] = 104] = "CASES_NOT_EXHAUSTIVE";
        /**
         * Reference not found.
         *
         * @generated from enum value: REFERENCE_NOT_FOUND = 105;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["REFERENCE_NOT_FOUND"] = 105] = "REFERENCE_NOT_FOUND";
        /**
         * Values are not comparable.
         *
         * @generated from enum value: NOT_COMPARABLE = 106;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["NOT_COMPARABLE"] = 106] = "NOT_COMPARABLE";
        /**
         * Not a finite number.
         *
         * @generated from enum value: NOT_FINITE_NUMBER = 107;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["NOT_FINITE_NUMBER"] = 107] = "NOT_FINITE_NUMBER";
        /**
         * Evaluation was aborted.
         *
         * @generated from enum value: ABORTED = 108;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["ABORTED"] = 108] = "ABORTED";
        /**
         * Unknown error.
         *
         * @generated from enum value: UNKNOWN_ERROR = 109;
         */
        EvaluateOutput_Status[EvaluateOutput_Status["UNKNOWN_ERROR"] = 109] = "UNKNOWN_ERROR";
    })(exports.EvaluateOutput_Status || (exports.EvaluateOutput_Status = {}));
    /**
     * Describes the enum exprml.v1.EvaluateOutput.Status.
     */
    const EvaluateOutput_StatusSchema = /*@__PURE__*/ codegenv1.enumDesc(file_exprml_v1_evaluator, 2, 0);

    // @generated by protoc-gen-es v2.2.0 with parameter "target=ts,import_extension=js"
    // @generated from file exprml/v1/parser.proto (package exprml.v1, syntax proto3)
    /* eslint-disable */
    /**
     * Describes the file exprml/v1/parser.proto.
     */
    const file_exprml_v1_parser = /*@__PURE__*/ codegenv1.fileDesc("ChZleHBybWwvdjEvcGFyc2VyLnByb3RvEglleHBybWwudjEiLQoKUGFyc2VJbnB1dBIfCgV2YWx1ZRgBIAEoCzIQLmV4cHJtbC52MS5WYWx1ZSJVCgtQYXJzZU91dHB1dBIQCghpc19lcnJvchgBIAEoCBIVCg1lcnJvcl9tZXNzYWdlGAIgASgJEh0KBGV4cHIYAyABKAsyDy5leHBybWwudjEuRXhwcjJCCgZQYXJzZXISOAoFUGFyc2USFS5leHBybWwudjEuUGFyc2VJbnB1dBoWLmV4cHJtbC52MS5QYXJzZU91dHB1dCIAQmEKDWNvbS5leHBybWwudjFCC1BhcnNlclByb3RvUAGiAgNFWFiqAglFeHBybWwuVjHKAglFeHBybWxcVjHiAhVFeHBybWxcVjFcR1BCTWV0YWRhdGHqAgpFeHBybWw6OlYxYgZwcm90bzM", [file_exprml_v1_expr, file_exprml_v1_value]);
    /**
     * Describes the message exprml.v1.ParseInput.
     * Use `create(ParseInputSchema)` to create a new message.
     */
    const ParseInputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_parser, 0);
    /**
     * Describes the message exprml.v1.ParseOutput.
     * Use `create(ParseOutputSchema)` to create a new message.
     */
    const ParseOutputSchema = /*@__PURE__*/ codegenv1.messageDesc(file_exprml_v1_parser, 1);

    class Decoder {
        decode(input) {
            try {
                return protobuf.create(DecodeOutputSchema, {
                    isError: false,
                    value: convertFromJS$1(YAML.parse(input.yaml)),
                });
            }
            catch (e) {
                return protobuf.create(DecodeOutputSchema, {
                    isError: true,
                    errorMessage: e instanceof Error ? e.message : JSON.stringify(e),
                });
            }
        }
    }
    function convertFromJS$1(v) {
        if (v == null) {
            return protobuf.create(ValueSchema, { type: exports.Value_Type.NULL });
        }
        if (Array.isArray(v)) {
            return protobuf.create(ValueSchema, { type: exports.Value_Type.ARR, arr: v.map(convertFromJS$1) });
        }
        switch (typeof v) {
            case "boolean":
                return protobuf.create(ValueSchema, { type: exports.Value_Type.BOOL, bool: v });
            case "number":
                return protobuf.create(ValueSchema, { type: exports.Value_Type.NUM, num: v });
            case "string":
                return protobuf.create(ValueSchema, { type: exports.Value_Type.STR, str: v });
            case "object":
                return protobuf.create(ValueSchema, {
                    type: exports.Value_Type.OBJ,
                    obj: Object.fromEntries(Object.entries(v).map(([k, v]) => [k, convertFromJS$1(v)]))
                });
        }
        throw new Error("unexpected value type");
    }

    class Encoder {
        encode(input) {
            try {
                switch (input.format) {
                    case exports.EncodeInput_Format.YAML:
                        return protobuf.create(EncodeOutputSchema, { result: YAML.stringify(convertFromJS(input.value)) });
                    case exports.EncodeInput_Format.JSON:
                        return protobuf.create(EncodeOutputSchema, { result: JSON.stringify(convertFromJS(input.value)) });
                    default:
                        return protobuf.create(EncodeOutputSchema, {
                            isError: true,
                            errorMessage: `unsupported format: ${exports.EncodeInput_Format[input.format]}`,
                        });
                }
            }
            catch (e) {
                return protobuf.create(EncodeOutputSchema, {
                    isError: true,
                    errorMessage: e instanceof Error ? e.message : JSON.stringify(e),
                });
            }
        }
    }
    function convertFromJS(v) {
        switch (v.type) {
            case exports.Value_Type.NULL:
                return null;
            case exports.Value_Type.BOOL:
                return v.bool;
            case exports.Value_Type.NUM:
                return v.num;
            case exports.Value_Type.STR:
                return v.str;
            case exports.Value_Type.OBJ:
                return Object.fromEntries(Object.entries(v.obj).map(([k, v]) => [k, convertFromJS(v)]));
            case exports.Value_Type.ARR:
                return v.arr.map(convertFromJS);
            default:
                throw new Error("unexpected value type");
        }
    }

    function append(path, ...pos) {
        const posList = [...pos].map((p) => typeof p === "string"
            ? protobuf.create(Expr_Path_PosSchema, { key: p })
            : protobuf.create(Expr_Path_PosSchema, { index: BigInt(p) }));
        return protobuf.create(Expr_PathSchema, { pos: [...path.pos, ...posList] });
    }
    function format(path) {
        if (path.pos.length === 0) {
            return "/";
        }
        return [...path.pos]
            .map((p) => p.key === "" ? `/${p.key}` : `/${p.index}`)
            .join("");
    }

    const regexNonIdentChars = /[^$_a-zA-Z0-9]/g;
    const regexFunctionDefinition = /^\$[_a-zA-Z][_a-zA-Z0-9]*(\(\s*\)|\(\s*\$[_a-zA-Z][_a-zA-Z0-9]*(\s*,\s*\$[_a-zA-Z][_a-zA-Z0-9]*)*(\s*,)?\s*\))?$/;
    const regexForVariables = /^for\(\s*\$[_a-zA-Z][_a-zA-Z0-9]*\s*,\s*\$[_a-zA-Z][_a-zA-Z0-9]*\s*\)$/;
    const regexIdentifier = /^\$[_a-zA-Z][_a-zA-Z0-9]*$/;
    class Parser {
        parse(input) {
            try {
                return protobuf.create(ParseOutputSchema, { expr: parseImpl(protobuf.create(Expr_PathSchema), input.value) });
            }
            catch (e) {
                return protobuf.create(ParseOutputSchema, {
                    isError: true,
                    errorMessage: e instanceof Error ? e.message : JSON.stringify(e),
                });
            }
        }
    }
    function parseImpl(path, value) {
        switch (value.type) {
            case exports.Value_Type.STR:
                if (regexIdentifier.test(value.str)) {
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.REF,
                        path: path,
                        ref: protobuf.create(RefSchema, { ident: value.str }),
                    });
                }
                if (/^`.*`$/.test(value.str)) {
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.SCALAR,
                        path: path,
                        scalar: protobuf.create(ScalarSchema, {
                            scalar: protobuf.create(ValueSchema, { type: exports.Value_Type.STR, str: value.str.slice(1, -1) })
                        }),
                    });
                }
                throw new Error(`invalid Scalar: ${path}: string literal must be enclosed by \`'\``);
            case exports.Value_Type.BOOL:
            case exports.Value_Type.NUM:
                return protobuf.create(ExprSchema, {
                    kind: exports.Expr_Kind.SCALAR,
                    path: path,
                    scalar: protobuf.create(ScalarSchema, { scalar: value }),
                });
            case exports.Value_Type.OBJ:
                if ("eval" in value.obj) {
                    const eval_ = protobuf.create(EvalSchema, {
                        eval: parseImpl(append(path, "eval"), value.obj["eval"]),
                    });
                    if ("where" in value.obj) {
                        const where = value.obj["where"];
                        if (where.type !== exports.Value_Type.ARR) {
                            throw new Error(`invalid Expr: ${format(append(path, "where"))}: where clause must be an array`);
                        }
                        const defs = [];
                        for (let i = 0; i < where.arr.length; i++) {
                            const def = where.arr[i];
                            if (def.type !== exports.Value_Type.OBJ) {
                                throw new Error(`invalid definition: ${format(append(path, "where", i))}: where clause must contain only objects but got ${def.type}`);
                            }
                            const keys = Object.keys(def.obj);
                            if (keys.length !== 1) {
                                throw new Error(`invalid definition: ${format(append(path, "where", i))}: definition must contain one property`);
                            }
                            const prop = keys[0];
                            if (!regexFunctionDefinition.test(prop)) {
                                throw new Error(`invalid definition: ${format(append(path, "where", i, prop))}: definition must match ${regexFunctionDefinition}`);
                            }
                            const idents = prop.replaceAll(regexNonIdentChars, "")
                                .split("$")
                                .map((s) => "$" + s);
                            defs.push(protobuf.create(Eval_DefinitionSchema, {
                                ident: idents[1],
                                args: idents.slice(2),
                                body: parseImpl(append(path, "where", i, prop), def.obj[prop]),
                            }));
                        }
                        eval_.where = defs;
                    }
                    return protobuf.create(ExprSchema, { kind: exports.Expr_Kind.EVAL, path: path, eval: eval_ });
                }
                if ("obj" in value.obj) {
                    const objVal = value.obj["obj"];
                    if (objVal.type !== exports.Value_Type.OBJ) {
                        throw new Error(`invalid Obj: ${format(append(path, "obj"))}: 'obj' property must be an object`);
                    }
                    const obj = Object.fromEntries(Object.entries(objVal.obj)
                        .map(([key, val]) => [key, parseImpl(append(path, "obj", key), val)]));
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.OBJ,
                        path: path,
                        obj: protobuf.create(ObjSchema, { obj: obj }),
                    });
                }
                if ("arr" in value.obj) {
                    const arrVal = value.obj["arr"];
                    if (arrVal.type !== exports.Value_Type.ARR) {
                        throw new Error(`invalid Arr: ${format(append(path, "arr"))}: 'arr' property must be an array`);
                    }
                    const arr = arrVal.arr
                        .map((val, i) => parseImpl(append(path, "arr", i), val));
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.ARR,
                        path: path,
                        arr: protobuf.create(ArrSchema, { arr: arr }),
                    });
                }
                if ("json" in value.obj) {
                    if (includesNull(value.obj["json"])) {
                        throw new Error(`invalid Json: ${format(append(path, "json"))}: 'json' property cannot contain null`);
                    }
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.JSON,
                        path: path,
                        json: protobuf.create(JsonSchema, { json: value.obj["json"] }),
                    });
                }
                if ("do" in value.obj) {
                    const iter = protobuf.create(IterSchema, {});
                    for (const prop of Object.keys(value.obj)) {
                        if (prop === "do") {
                            iter.do = parseImpl(append(path, "do"), value.obj["do"]);
                            continue;
                        }
                        if (prop === "if") {
                            iter.if = parseImpl(append(path, "if"), value.obj["if"]);
                            continue;
                        }
                        if (regexForVariables.test(prop)) {
                            const idents = prop.replaceAll(regexNonIdentChars, "")
                                .split("$")
                                .map((s) => "$" + s);
                            iter.posIdent = idents[1];
                            iter.elemIdent = idents[2];
                            iter.col = parseImpl(append(path, prop), value.obj[prop]);
                            continue;
                        }
                        throw new Error(`invalid Iter: ${format(append(path, "do", prop))}: invalid property ${prop}`);
                    }
                    if (!iter.col) {
                        throw new Error(`invalid Iter: ${format(path)}: 'for(...vars...)' property is required`);
                    }
                    return protobuf.create(ExprSchema, { kind: exports.Expr_Kind.ITER, path: path, iter: iter });
                }
                if ("get" in value.obj) {
                    if (!("from" in value.obj)) {
                        throw new Error(`invalid Elem: ${format(path)}: 'from' property is required`);
                    }
                    const elem = protobuf.create(ElemSchema, {
                        get: parseImpl(append(path, "get"), value.obj["get"]),
                        from: parseImpl(append(path, "from"), value.obj["from"]),
                    });
                    return protobuf.create(ExprSchema, { kind: exports.Expr_Kind.ELEM, path: path, elem: elem });
                }
                if ("cases" in value.obj) {
                    const casesVal = value.obj["cases"];
                    if (casesVal.type !== exports.Value_Type.ARR) {
                        throw new Error(`invalid Cases: ${format(append(path, "cases"))}: 'cases' property must be an array`);
                    }
                    const cases = [];
                    for (let i = 0; i < casesVal.arr.length; i++) {
                        const c = casesVal.arr[i];
                        if (c.type !== exports.Value_Type.OBJ) {
                            throw new Error(`invalid Case: ${format(append(path, "cases", i))}: 'cases' property must contain only objects but got ${c.type}`);
                        }
                        if ("otherwise" in c.obj) {
                            const otherwise = parseImpl(append(path, "cases", i, "otherwise"), c.obj["otherwise"]);
                            cases.push(protobuf.create(Cases_CaseSchema, { isOtherwise: true, otherwise: otherwise, }));
                        }
                        else {
                            if (!("when" in c.obj)) {
                                throw new Error(`invalid Case: ${format(append(path, "cases", i))}: 'when' property is required`);
                            }
                            const when = parseImpl(append(path, "cases", i, "when"), c.obj["when"]);
                            if (!("then" in c.obj)) {
                                throw new Error(`invalid Case: ${format(append(path, "cases", i))}: 'then' property is required`);
                            }
                            const then = parseImpl(append(path, "cases", i, "then"), c.obj["then"]);
                            cases.push(protobuf.create(Cases_CaseSchema, { when: when, then: then }));
                        }
                    }
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.CASES,
                        path: path,
                        cases: protobuf.create(CasesSchema, { cases: cases }),
                    });
                }
                if (Object.keys(value.obj).length !== 1) {
                    throw new Error(`invalid Expr: ${format(path)}: operation or function call must contain only one property`);
                }
                const prop = Object.keys(value.obj)[0];
                {
                    const opUnary = {
                        "len": exports.OpUnary_Op.LEN,
                        "not": exports.OpUnary_Op.NOT,
                        "flat": exports.OpUnary_Op.FLAT,
                        "floor": exports.OpUnary_Op.FLOOR,
                        "ceil": exports.OpUnary_Op.CEIL,
                        "abort": exports.OpUnary_Op.ABORT,
                    }[prop];
                    if (opUnary) {
                        return protobuf.create(ExprSchema, {
                            kind: exports.Expr_Kind.OP_UNARY,
                            path: path,
                            opUnary: protobuf.create(OpUnarySchema, {
                                op: opUnary,
                                operand: parseImpl(append(path, prop), value.obj[prop])
                            }),
                        });
                    }
                }
                {
                    const opBinary = {
                        "sub": exports.OpBinary_Op.SUB,
                        "div": exports.OpBinary_Op.DIV,
                        "eq": exports.OpBinary_Op.EQ,
                        "neq": exports.OpBinary_Op.NEQ,
                        "lt": exports.OpBinary_Op.LT,
                        "lte": exports.OpBinary_Op.LTE,
                        "gt": exports.OpBinary_Op.GT,
                        "gte": exports.OpBinary_Op.GTE,
                    }[prop];
                    if (opBinary) {
                        if (value.obj[prop].type !== exports.Value_Type.ARR) {
                            throw new Error(`invalid OpBinary: ${format(append(path, prop))}: '${prop}' property must be an array`);
                        }
                        if (value.obj[prop].arr.length !== 2) {
                            throw new Error(`invalid OpBinary: ${format(append(path, prop))}: '${prop}' property must contain two elements`);
                        }
                        return protobuf.create(ExprSchema, {
                            kind: exports.Expr_Kind.OP_BINARY,
                            path: path,
                            opBinary: protobuf.create(OpBinarySchema, {
                                op: opBinary,
                                left: parseImpl(append(path, prop, 0), value.obj[prop].arr[0]),
                                right: parseImpl(append(path, prop, 1), value.obj[prop].arr[1]),
                            }),
                        });
                    }
                }
                {
                    const opVariadic = {
                        "add": exports.OpVariadic_Op.ADD,
                        "mul": exports.OpVariadic_Op.MUL,
                        "and": exports.OpVariadic_Op.AND,
                        "or": exports.OpVariadic_Op.OR,
                        "cat": exports.OpVariadic_Op.CAT,
                        "min": exports.OpVariadic_Op.MIN,
                        "max": exports.OpVariadic_Op.MAX,
                        "merge": exports.OpVariadic_Op.MERGE,
                    }[prop];
                    if (opVariadic) {
                        if (value.obj[prop].type !== exports.Value_Type.ARR) {
                            throw new Error(`invalid OpVariadic: ${format(append(path, prop))}: '${prop}' property must be an array`);
                        }
                        if ((prop === "min" || prop === "max") && value.obj[prop].arr.length === 0) {
                            throw new Error(`invalid OpVariadic: ${format(append(path, prop))}: '${prop}' property must contain at least one element`);
                        }
                        const arr = value.obj[prop].arr
                            .map((val, i) => parseImpl(append(path, prop, i), val));
                        return protobuf.create(ExprSchema, {
                            kind: exports.Expr_Kind.OP_VARIADIC,
                            path: path,
                            opVariadic: protobuf.create(OpVariadicSchema, { op: opVariadic, operands: arr }),
                        });
                    }
                }
                {
                    if (!regexIdentifier.test(prop)) {
                        throw new Error(`invalid Call: ${format(path)}: function call property '${prop}' must match '${regexIdentifier}'`);
                    }
                    const argsVal = value.obj[prop];
                    if (argsVal.type !== exports.Value_Type.OBJ) {
                        throw new Error(`invalid Call: ${format(append(path, prop))}: arguments must be given as an object`);
                    }
                    const args = {};
                    for (const [key, val] of Object.entries(argsVal.obj)) {
                        if (!regexIdentifier.test(key)) {
                            throw new Error(`invalid Call: ${format(append(path, prop, key))}: argument property '${key}' must match '${regexIdentifier}'`);
                        }
                        args[key] = parseImpl(append(path, prop, key), val);
                    }
                    return protobuf.create(ExprSchema, {
                        kind: exports.Expr_Kind.CALL,
                        path: path,
                        call: protobuf.create(CallSchema, { ident: prop, args: args }),
                    });
                }
            default:
                throw new Error("unexpected value type");
        }
    }
    function includesNull(value) {
        if (value.type === exports.Value_Type.NULL) {
            return true;
        }
        for (const v of Object.values(value.obj)) {
            if (includesNull(v)) {
                return true;
            }
        }
        for (const v of value.arr) {
            if (includesNull(v)) {
                return true;
            }
        }
        return false;
    }

    function register(defStack, def) {
        return protobuf.create(DefStackSchema, {
            parent: defStack,
            def: def,
        });
    }
    function find(defStack, ident) {
        if (defStack == null || defStack.def == null) {
            return null;
        }
        if (defStack.def?.ident === ident) {
            return defStack;
        }
        if (defStack.parent == null) {
            return null;
        }
        return find(defStack.parent, ident);
    }
    function newDefinition(path, ident, value) {
        return protobuf.create(Eval_DefinitionSchema, {
            ident: ident,
            body: protobuf.create(ExprSchema, {
                path: path,
                kind: exports.Expr_Kind.JSON,
                value: value,
                json: protobuf.create(JsonSchema, { json: value }),
            }),
        });
    }

    function objValue(obj) {
        return protobuf.create(ValueSchema, { type: exports.Value_Type.OBJ, obj: obj });
    }
    function arrValue(arr) {
        return protobuf.create(ValueSchema, { type: exports.Value_Type.ARR, arr: arr });
    }
    function strValue(str) {
        return protobuf.create(ValueSchema, { type: exports.Value_Type.STR, str: str });
    }
    function numValue(num) {
        return protobuf.create(ValueSchema, { type: exports.Value_Type.NUM, num: num });
    }
    function boolValue(b) {
        return protobuf.create(ValueSchema, { type: exports.Value_Type.BOOL, bool: b });
    }

    class Config {
        constructor(props) {
            this.extension = props?.extension ?? new Map();
            this.beforeEvaluate = props?.beforeEvaluate ?? (() => undefined);
            this.afterEvaluate = props?.afterEvaluate ?? (() => undefined);
        }
        extension;
        beforeEvaluate;
        afterEvaluate;
    }
    class Evaluator {
        constructor(config = new Config()) {
            this.config = config;
        }
        config;
        evaluateExpr(input) {
            try {
                this.config.beforeEvaluate(input);
            }
            catch (err) {
                return protobuf.create(EvaluateOutputSchema, {
                    status: exports.EvaluateOutput_Status.UNKNOWN_ERROR,
                    errorPath: input.expr.path,
                    errorMessage: `beforeEvaluate failed: ${err instanceof Error ? err.message : JSON.stringify(err)}`,
                });
            }
            let output;
            switch (input.expr.kind) {
                default:
                    throw new Error("given expression must be validated");
                case exports.Expr_Kind.EVAL:
                    output = this.evaluateEval(input);
                    break;
                case exports.Expr_Kind.SCALAR:
                    output = this.evaluateScalar(input);
                    break;
                case exports.Expr_Kind.REF:
                    output = this.evaluateRef(input);
                    break;
                case exports.Expr_Kind.OBJ:
                    output = this.evaluateObj(input);
                    break;
                case exports.Expr_Kind.ARR:
                    output = this.evaluateArr(input);
                    break;
                case exports.Expr_Kind.JSON:
                    output = this.evaluateJson(input);
                    break;
                case exports.Expr_Kind.ITER:
                    output = this.evaluateIter(input);
                    break;
                case exports.Expr_Kind.ELEM:
                    output = this.evaluateElem(input);
                    break;
                case exports.Expr_Kind.CALL:
                    output = this.evaluateCall(input);
                    break;
                case exports.Expr_Kind.CASES:
                    output = this.evaluateCases(input);
                    break;
                case exports.Expr_Kind.OP_UNARY:
                    output = this.evaluateOpUnary(input);
                    break;
                case exports.Expr_Kind.OP_BINARY:
                    output = this.evaluateOpBinary(input);
                    break;
                case exports.Expr_Kind.OP_VARIADIC:
                    output = this.evaluateOpVariadic(input);
                    break;
            }
            try {
                this.config.afterEvaluate(input, output);
            }
            catch (err) {
                return protobuf.create(EvaluateOutputSchema, {
                    status: exports.EvaluateOutput_Status.UNKNOWN_ERROR,
                    errorPath: input.expr.path,
                    errorMessage: `afterEvaluate failed: ${err instanceof Error ? err.message : JSON.stringify(err)}`,
                });
            }
            return output;
        }
        evaluateEval(input) {
            let st = input.defStack;
            const where = input.expr.eval?.where ?? [];
            for (const def of where) {
                st = register(st, def);
            }
            return this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: input.expr.eval.eval }));
        }
        evaluateScalar(input) {
            return protobuf.create(EvaluateOutputSchema, { value: input.expr.scalar.scalar });
        }
        evaluateRef(input) {
            const ref = input.expr.ref;
            let st = find(input.defStack, ref.ident);
            if (!st) {
                const ext = this.config.extension.get(ref.ident);
                if (!ext) {
                    return errorReferenceNotFound(input.expr.path, ref.ident);
                }
                return ext(input.expr.path, {});
            }
            return this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: st.def.body }));
        }
        evaluateObj(input) {
            const result = {};
            for (const [pos, expr] of Object.entries(input.expr.obj.obj)) {
                const val = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: expr }));
                if (val.status !== exports.EvaluateOutput_Status.OK) {
                    return val;
                }
                result[pos] = val.value;
            }
            return protobuf.create(EvaluateOutputSchema, { value: objValue(result) });
        }
        evaluateArr(input) {
            const result = [];
            for (const expr of input.expr.arr.arr) {
                const val = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: expr }));
                if (val.status !== exports.EvaluateOutput_Status.OK) {
                    return val;
                }
                result.push(val.value);
            }
            return protobuf.create(EvaluateOutputSchema, { value: arrValue(result) });
        }
        evaluateJson(input) {
            return protobuf.create(EvaluateOutputSchema, { value: input.expr.json.json });
        }
        evaluateIter(input) {
            const iter = input.expr.iter;
            const forPos = iter.posIdent;
            const forElem = iter.elemIdent;
            const inVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: iter.col }));
            switch (inVal.value.type) {
                case exports.Value_Type.STR:
                    const strResult = [];
                    for (let i = 0; i < inVal.value.str.length; i++) {
                        let st = input.defStack;
                        st = register(st, newDefinition(input.expr.path, forPos, numValue(i)));
                        st = register(st, newDefinition(input.expr.path, forElem, strValue(inVal.value.str[i])));
                        if (iter.if) {
                            const ifVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.if }));
                            if (ifVal.status !== exports.EvaluateOutput_Status.OK) {
                                return ifVal;
                            }
                            if (ifVal.value.type !== exports.Value_Type.BOOL) {
                                return errorUnexpectedType(iter.if.path, ifVal.value.type, [exports.Value_Type.BOOL]);
                            }
                            if (!ifVal.value.bool) {
                                continue;
                            }
                        }
                        const v = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.do }));
                        if (v.status !== exports.EvaluateOutput_Status.OK) {
                            return v;
                        }
                        strResult.push(v.value);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: arrValue(strResult) });
                case exports.Value_Type.ARR:
                    const arrResult = [];
                    for (let i = 0; i < inVal.value.arr.length; i++) {
                        let st = input.defStack;
                        st = register(st, newDefinition(input.expr.path, forPos, numValue(i)));
                        st = register(st, newDefinition(input.expr.path, forElem, inVal.value.arr[i]));
                        if (iter.if) {
                            const ifVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.if }));
                            if (ifVal.status !== exports.EvaluateOutput_Status.OK) {
                                return ifVal;
                            }
                            if (ifVal.value.type !== exports.Value_Type.BOOL) {
                                return errorUnexpectedType(iter.if.path, ifVal.value.type, [exports.Value_Type.BOOL]);
                            }
                            if (!ifVal.value.bool) {
                                continue;
                            }
                        }
                        const v = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.do }));
                        if (v.status !== exports.EvaluateOutput_Status.OK) {
                            return v;
                        }
                        arrResult.push(v.value);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: arrValue(arrResult) });
                case exports.Value_Type.OBJ:
                    const objResult = {};
                    for (const key of sortedKeys(inVal.value.obj)) {
                        let st = input.defStack;
                        st = register(st, newDefinition(input.expr.path, forPos, strValue(key)));
                        st = register(st, newDefinition(input.expr.path, forElem, inVal.value.obj[key]));
                        if (iter.if) {
                            const ifVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.if }));
                            if (ifVal.status !== exports.EvaluateOutput_Status.OK) {
                                return ifVal;
                            }
                            if (ifVal.value.type !== exports.Value_Type.BOOL) {
                                return errorUnexpectedType(iter.if.path, ifVal.value.type, [exports.Value_Type.BOOL]);
                            }
                            if (!ifVal.value.bool) {
                                continue;
                            }
                        }
                        const v = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: iter.do }));
                        if (v.status !== exports.EvaluateOutput_Status.OK) {
                            return v;
                        }
                        objResult[key] = v.value;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: objValue(objResult) });
                default:
                    return errorUnexpectedType(iter.col.path, inVal.value.type, [exports.Value_Type.STR, exports.Value_Type.ARR, exports.Value_Type.OBJ]);
            }
        }
        evaluateElem(input) {
            const elem = input.expr.elem;
            const getVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: elem.get }));
            if (getVal.status !== exports.EvaluateOutput_Status.OK) {
                return getVal;
            }
            const pos = getVal.value;
            const fromVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: elem.from }));
            if (fromVal.status !== exports.EvaluateOutput_Status.OK) {
                return fromVal;
            }
            const col = fromVal.value;
            switch (col.type) {
                case exports.Value_Type.STR:
                    if (pos.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(elem.get.path, pos.type, [exports.Value_Type.NUM]);
                    }
                    if (!canInt(pos)) {
                        return errorIndexNotInteger(elem.get.path, pos.num);
                    }
                    const idxStr = Math.floor(pos.num);
                    if (idxStr < 0 || idxStr >= col.str.length) {
                        return errorIndexOutOfBounds(elem.get.path, pos, 0, col.str.length);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: strValue(col.str[idxStr]) });
                case exports.Value_Type.ARR:
                    if (pos.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(elem.get.path, pos.type, [exports.Value_Type.NUM]);
                    }
                    if (!canInt(pos)) {
                        return errorIndexNotInteger(elem.get.path, pos.num);
                    }
                    const idxArr = Math.floor(pos.num);
                    if (idxArr < 0 || idxArr >= col.arr.length) {
                        return errorIndexOutOfBounds(elem.get.path, pos, 0, col.arr.length);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: col.arr[idxArr] });
                case exports.Value_Type.OBJ:
                    if (pos.type !== exports.Value_Type.STR) {
                        return errorUnexpectedType(elem.get.path, pos.type, [exports.Value_Type.STR]);
                    }
                    const key = pos.str;
                    if (!(key in col.obj)) {
                        return errorInvalidKey(elem.get.path, key, Object.keys(col.obj));
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: col.obj[key] });
                default:
                    return errorUnexpectedType(elem.from.path, col.type, [exports.Value_Type.STR, exports.Value_Type.ARR, exports.Value_Type.OBJ]);
            }
        }
        evaluateCall(input) {
            const call = input.expr.call;
            let st = find(input.defStack, call.ident);
            if (!st) {
                const ext = this.config.extension.get(call.ident);
                if (!ext) {
                    return errorReferenceNotFound(input.expr.path, call.ident);
                }
                const args = {};
                for (const [argName, argExpr] of Object.entries(call.args)) {
                    const argVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, {
                        defStack: input.defStack,
                        expr: argExpr
                    }));
                    if (argVal.status !== exports.EvaluateOutput_Status.OK) {
                        return argVal;
                    }
                    args[argName] = argVal.value;
                }
                return ext(input.expr.path, args);
            }
            const def = st.def;
            for (const argName of def.args) {
                const arg = call.args[argName];
                if (!arg) {
                    return errorArgumentMismatch(input.expr.path, argName);
                }
                const argVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: arg }));
                if (argVal.status !== exports.EvaluateOutput_Status.OK) {
                    return argVal;
                }
                st = register(st, newDefinition(append(input.expr.path, call.ident, argName), argName, argVal.value));
            }
            return this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: st, expr: def.body }));
        }
        evaluateCases(input) {
            const cases = input.expr.cases.cases;
            for (const case_ of cases) {
                if (case_.isOtherwise) {
                    return this.evaluateExpr(protobuf.create(EvaluateInputSchema, {
                        defStack: input.defStack,
                        expr: case_.otherwise
                    }));
                }
                else {
                    const boolVal = this.evaluateExpr(protobuf.create(EvaluateInputSchema, {
                        defStack: input.defStack,
                        expr: case_.when
                    }));
                    if (boolVal.status !== exports.EvaluateOutput_Status.OK) {
                        return boolVal;
                    }
                    if (boolVal.value.type !== exports.Value_Type.BOOL) {
                        return errorUnexpectedType(case_.when.path, boolVal.value.type, [exports.Value_Type.BOOL]);
                    }
                    if (boolVal.value.bool) {
                        return this.evaluateExpr(protobuf.create(EvaluateInputSchema, {
                            defStack: input.defStack,
                            expr: case_.then
                        }));
                    }
                }
            }
            return errorCasesNotExhaustive(append(input.expr.path, "cases"));
        }
        evaluateOpUnary(input) {
            const op = input.expr.opUnary;
            const o = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: op.operand }));
            if (o.status !== exports.EvaluateOutput_Status.OK) {
                return o;
            }
            const operand = o.value;
            switch (op.op) {
                case exports.OpUnary_Op.LEN:
                    switch (operand.type) {
                        case exports.Value_Type.STR:
                            return protobuf.create(EvaluateOutputSchema, { value: numValue(operand.str.length) });
                        case exports.Value_Type.ARR:
                            return protobuf.create(EvaluateOutputSchema, { value: numValue(operand.arr.length) });
                        case exports.Value_Type.OBJ:
                            return protobuf.create(EvaluateOutputSchema, { value: numValue(Object.keys(operand.obj).length) });
                        default:
                            return errorUnexpectedType(append(input.expr.path, "len"), operand.type, [exports.Value_Type.STR, exports.Value_Type.ARR, exports.Value_Type.OBJ]);
                    }
                case exports.OpUnary_Op.NOT:
                    if (operand.type !== exports.Value_Type.BOOL) {
                        return errorUnexpectedType(append(input.expr.path, "not"), operand.type, [exports.Value_Type.BOOL]);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(!operand.bool) });
                case exports.OpUnary_Op.FLAT:
                    if (operand.type !== exports.Value_Type.ARR) {
                        return errorUnexpectedType(append(input.expr.path, "flat"), operand.type, [exports.Value_Type.ARR]);
                    }
                    const flatArr = [];
                    for (const elem of operand.arr) {
                        if (elem.type !== exports.Value_Type.ARR) {
                            return errorUnexpectedType(append(input.expr.path, "flat"), elem.type, [exports.Value_Type.ARR]);
                        }
                        flatArr.push(...elem.arr);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: arrValue(flatArr) });
                case exports.OpUnary_Op.FLOOR:
                    if (operand.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "floor"), operand.type, [exports.Value_Type.NUM]);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(Math.floor(operand.num)) });
                case exports.OpUnary_Op.CEIL:
                    if (operand.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "ceil"), operand.type, [exports.Value_Type.NUM]);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(Math.ceil(operand.num)) });
                case exports.OpUnary_Op.ABORT:
                    if (operand.type !== exports.Value_Type.STR) {
                        return errorUnexpectedType(append(input.expr.path, "abort"), operand.type, [exports.Value_Type.STR]);
                    }
                    return protobuf.create(EvaluateOutputSchema, { status: exports.EvaluateOutput_Status.ABORTED, errorMessage: operand.str });
                default:
                    throw new Error(`unexpected unary operator ${exports.OpUnary_Op[op.op]}`);
            }
        }
        evaluateOpBinary(input) {
            const op = input.expr.opBinary;
            const ol = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: op.left }));
            if (ol.status !== exports.EvaluateOutput_Status.OK) {
                return ol;
            }
            const or = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: op.right }));
            if (or.status !== exports.EvaluateOutput_Status.OK) {
                return or;
            }
            const operandL = ol.value;
            const operandR = or.value;
            switch (op.op) {
                case exports.OpBinary_Op.SUB:
                    if (operandL.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "sub", 0), operandL.type, [exports.Value_Type.NUM]);
                    }
                    if (operandR.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "sub", 1), operandR.type, [exports.Value_Type.NUM]);
                    }
                    const subResult = operandL.num - operandR.num;
                    if (!isFinite(subResult)) {
                        return errorNotFiniteNumber(input.expr.path);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(subResult) });
                case exports.OpBinary_Op.DIV:
                    if (operandL.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "div", 0), operandL.type, [exports.Value_Type.NUM]);
                    }
                    if (operandR.type !== exports.Value_Type.NUM) {
                        return errorUnexpectedType(append(input.expr.path, "div", 1), operandR.type, [exports.Value_Type.NUM]);
                    }
                    const divResult = operandL.num / operandR.num;
                    if (!isFinite(divResult)) {
                        return errorNotFiniteNumber(input.expr.path);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(divResult) });
                case exports.OpBinary_Op.EQ:
                    return protobuf.create(EvaluateOutputSchema, { value: equal(operandL, operandR) });
                case exports.OpBinary_Op.NEQ:
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(!equal(operandL, operandR).bool) });
                case exports.OpBinary_Op.LT:
                    const ltCmpVal = compare(append(input.expr.path, "lt"), operandL, operandR);
                    if (ltCmpVal.status !== exports.EvaluateOutput_Status.OK) {
                        return ltCmpVal;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(ltCmpVal.value.num < 0) });
                case exports.OpBinary_Op.LTE:
                    const lteCmpVal = compare(append(input.expr.path, "lte"), operandL, operandR);
                    if (lteCmpVal.status !== exports.EvaluateOutput_Status.OK) {
                        return lteCmpVal;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(lteCmpVal.value.num <= 0) });
                case exports.OpBinary_Op.GT:
                    const gtCmpVal = compare(append(input.expr.path, "gt"), operandL, operandR);
                    if (gtCmpVal.status !== exports.EvaluateOutput_Status.OK) {
                        return gtCmpVal;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(gtCmpVal.value.num > 0) });
                case exports.OpBinary_Op.GTE:
                    const gteCmpVal = compare(append(input.expr.path, "gte"), operandL, operandR);
                    if (gteCmpVal.status !== exports.EvaluateOutput_Status.OK) {
                        return gteCmpVal;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(gteCmpVal.value.num >= 0) });
                default:
                    throw new Error(`unexpected binary operator ${exports.OpBinary_Op[op.op]}`);
            }
        }
        evaluateOpVariadic(input) {
            const op = input.expr.opVariadic;
            const operands = [];
            for (const elem of op.operands) {
                const val = this.evaluateExpr(protobuf.create(EvaluateInputSchema, { defStack: input.defStack, expr: elem }));
                if (val.status !== exports.EvaluateOutput_Status.OK) {
                    return val;
                }
                operands.push(val.value);
            }
            switch (op.op) {
                case exports.OpVariadic_Op.ADD:
                    let addVal = 0.0;
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.NUM) {
                            return errorUnexpectedType(append(input.expr.path, "add", i), operand.type, [exports.Value_Type.NUM]);
                        }
                        addVal += operand.num;
                    }
                    if (!isFinite(addVal)) {
                        return errorNotFiniteNumber(append(input.expr.path, "add"));
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(addVal) });
                case exports.OpVariadic_Op.MUL:
                    let mulVal = 1.0;
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.NUM) {
                            return errorUnexpectedType(append(input.expr.path, "mul", i), operand.type, [exports.Value_Type.NUM]);
                        }
                        mulVal *= operand.num;
                    }
                    if (!isFinite(mulVal)) {
                        return errorNotFiniteNumber(append(input.expr.path, "mul"));
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(mulVal) });
                case exports.OpVariadic_Op.AND:
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.BOOL) {
                            return errorUnexpectedType(append(input.expr.path, "and", i), operand.type, [exports.Value_Type.BOOL]);
                        }
                        if (!operand.bool) {
                            return protobuf.create(EvaluateOutputSchema, { value: boolValue(false) });
                        }
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(true) });
                case exports.OpVariadic_Op.OR:
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.BOOL) {
                            return errorUnexpectedType(append(input.expr.path, "or", i), operand.type, [exports.Value_Type.BOOL]);
                        }
                        if (operand.bool) {
                            return protobuf.create(EvaluateOutputSchema, { value: boolValue(true) });
                        }
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: boolValue(false) });
                case exports.OpVariadic_Op.CAT:
                    let catVal = "";
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.STR) {
                            return errorUnexpectedType(append(input.expr.path, "cat", i), operand.type, [exports.Value_Type.STR]);
                        }
                        catVal += operand.str;
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: strValue(catVal) });
                case exports.OpVariadic_Op.MIN:
                    let minVal = Infinity;
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.NUM) {
                            return errorUnexpectedType(append(input.expr.path, "min", i), operand.type, [exports.Value_Type.NUM]);
                        }
                        minVal = Math.min(minVal, operand.num);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(minVal) });
                case exports.OpVariadic_Op.MAX:
                    let maxVal = -Infinity;
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.NUM) {
                            return errorUnexpectedType(append(input.expr.path, "max", i), operand.type, [exports.Value_Type.NUM]);
                        }
                        maxVal = Math.max(maxVal, operand.num);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: numValue(maxVal) });
                case exports.OpVariadic_Op.MERGE:
                    const mergeVal = {};
                    for (let i = 0; i < operands.length; i++) {
                        const operand = operands[i];
                        if (operand.type !== exports.Value_Type.OBJ) {
                            return errorUnexpectedType(append(input.expr.path, "merge", i), operand.type, [exports.Value_Type.OBJ]);
                        }
                        Object.assign(mergeVal, operand.obj);
                    }
                    return protobuf.create(EvaluateOutputSchema, { value: objValue(mergeVal) });
                default:
                    throw new Error(`unexpected variadic operator ${exports.OpVariadic_Op[op.op]}`);
            }
        }
    }
    function errorIndexOutOfBounds(path, index, begin, end) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.INVALID_INDEX,
            errorPath: path,
            errorMessage: `invalid index: index out of bounds: ${index.num} not in [${begin}, ${end})`,
        });
    }
    function errorIndexNotInteger(path, index) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.INVALID_INDEX,
            errorPath: path,
            errorMessage: `invalid index: non integer index: ${index}`,
        });
    }
    function errorInvalidKey(path, key, keys) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.INVALID_INDEX,
            errorPath: path,
            errorMessage: `invalid key: "${key}" not in {${keys.join(",")}}`,
        });
    }
    function errorUnexpectedType(path, got, want) {
        const wantStr = want.map(t => t.toString());
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.UNEXPECTED_TYPE,
            errorPath: path,
            errorMessage: `unexpected type: got ${got.toString()}, want {${wantStr.join(",")}}`,
        });
    }
    function errorArgumentMismatch(path, arg) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.ARGUMENT_MISMATCH,
            errorPath: path,
            errorMessage: `argument mismatch: argument "${arg}" required`,
        });
    }
    function errorReferenceNotFound(path, ref) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.REFERENCE_NOT_FOUND,
            errorPath: path,
            errorMessage: `reference not found: "${ref}"`,
        });
    }
    function errorCasesNotExhaustive(path) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.CASES_NOT_EXHAUSTIVE,
            errorPath: path,
            errorMessage: "cases not exhaustive",
        });
    }
    function errorNotComparable(path) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.NOT_COMPARABLE,
            errorPath: path,
            errorMessage: "not comparable",
        });
    }
    function errorNotFiniteNumber(path) {
        return protobuf.create(EvaluateOutputSchema, {
            status: exports.EvaluateOutput_Status.NOT_FINITE_NUMBER,
            errorPath: path,
            errorMessage: "not finite number",
        });
    }
    function canInt(v) {
        return v.type === exports.Value_Type.NUM && v.num === Math.floor(v.num);
    }
    function sortedKeys(m) {
        return Object.keys(m).sort();
    }
    function equal(l, r) {
        const falseValue = boolValue(false);
        const trueValue = boolValue(true);
        if (l.type !== r.type) {
            return falseValue;
        }
        switch (l.type) {
            case exports.Value_Type.NUM:
                return boolValue(l.num === r.num);
            case exports.Value_Type.BOOL:
                return boolValue(l.bool === r.bool);
            case exports.Value_Type.STR:
                return boolValue(l.str === r.str);
            case exports.Value_Type.ARR:
                if (l.arr.length !== r.arr.length) {
                    return falseValue;
                }
                for (let i = 0; i < l.arr.length; i++) {
                    if (!equal(l.arr[i], r.arr[i]).bool) {
                        return falseValue;
                    }
                }
                return trueValue;
            case exports.Value_Type.OBJ:
                const lKeys = sortedKeys(l.obj);
                const rKeys = sortedKeys(r.obj);
                if (lKeys.length !== rKeys.length || !lKeys.every((key, i) => key === rKeys[i])) {
                    return falseValue;
                }
                for (const key of lKeys) {
                    if (!equal(l.obj[key], r.obj[key]).bool) {
                        return falseValue;
                    }
                }
                return trueValue;
            default:
                throw new Error(`unexpected type ${l.type}`);
        }
    }
    function compare(path, l, r) {
        const ltValue = protobuf.create(EvaluateOutputSchema, { value: numValue(-1) });
        const gtValue = protobuf.create(EvaluateOutputSchema, { value: numValue(1) });
        const eqValue = protobuf.create(EvaluateOutputSchema, { value: numValue(0) });
        switch (l.type) {
            case exports.Value_Type.NUM:
                if (r.type !== exports.Value_Type.NUM) {
                    return errorNotComparable(path);
                }
                return l.num < r.num ? ltValue : l.num > r.num ? gtValue : eqValue;
            case exports.Value_Type.BOOL:
                if (r.type !== exports.Value_Type.BOOL) {
                    return errorNotComparable(path);
                }
                return !l.bool && r.bool ? ltValue : l.bool && !r.bool ? gtValue : eqValue;
            case exports.Value_Type.STR:
                if (r.type !== exports.Value_Type.STR) {
                    return errorNotComparable(path);
                }
                return l.str < r.str ? ltValue : l.str > r.str ? gtValue : eqValue;
            case exports.Value_Type.ARR:
                if (r.type !== exports.Value_Type.ARR) {
                    return errorNotComparable(path);
                }
                const minLength = Math.min(l.arr.length, r.arr.length);
                for (let i = 0; i < minLength; i++) {
                    const cmp = compare(path, l.arr[i], r.arr[i]);
                    if (cmp.status !== exports.EvaluateOutput_Status.OK) {
                        return cmp;
                    }
                    if (cmp.value.num !== 0) {
                        return cmp;
                    }
                }
                return l.arr.length < r.arr.length ? ltValue : l.arr.length > r.arr.length ? gtValue : eqValue;
            default:
                return errorNotComparable(path);
        }
    }

    exports.ArrSchema = ArrSchema;
    exports.CallSchema = CallSchema;
    exports.CasesSchema = CasesSchema;
    exports.Cases_CaseSchema = Cases_CaseSchema;
    exports.Config = Config;
    exports.DecodeInputSchema = DecodeInputSchema;
    exports.DecodeOutputSchema = DecodeOutputSchema;
    exports.Decoder = Decoder;
    exports.DefStackSchema = DefStackSchema;
    exports.ElemSchema = ElemSchema;
    exports.EncodeInputSchema = EncodeInputSchema;
    exports.EncodeInput_FormatSchema = EncodeInput_FormatSchema;
    exports.EncodeOutputSchema = EncodeOutputSchema;
    exports.Encoder = Encoder;
    exports.EvalSchema = EvalSchema;
    exports.Eval_DefinitionSchema = Eval_DefinitionSchema;
    exports.EvaluateInputSchema = EvaluateInputSchema;
    exports.EvaluateOutputSchema = EvaluateOutputSchema;
    exports.EvaluateOutput_StatusSchema = EvaluateOutput_StatusSchema;
    exports.Evaluator = Evaluator;
    exports.ExprSchema = ExprSchema;
    exports.Expr_KindSchema = Expr_KindSchema;
    exports.Expr_PathSchema = Expr_PathSchema;
    exports.Expr_Path_PosSchema = Expr_Path_PosSchema;
    exports.IterSchema = IterSchema;
    exports.JsonSchema = JsonSchema;
    exports.ObjSchema = ObjSchema;
    exports.OpBinarySchema = OpBinarySchema;
    exports.OpBinary_OpSchema = OpBinary_OpSchema;
    exports.OpUnarySchema = OpUnarySchema;
    exports.OpUnary_OpSchema = OpUnary_OpSchema;
    exports.OpVariadicSchema = OpVariadicSchema;
    exports.OpVariadic_OpSchema = OpVariadic_OpSchema;
    exports.ParseInputSchema = ParseInputSchema;
    exports.ParseOutputSchema = ParseOutputSchema;
    exports.Parser = Parser;
    exports.RefSchema = RefSchema;
    exports.ScalarSchema = ScalarSchema;
    exports.ValueSchema = ValueSchema;
    exports.Value_TypeSchema = Value_TypeSchema;
    exports.append = append;
    exports.arrValue = arrValue;
    exports.boolValue = boolValue;
    exports.find = find;
    exports.format = format;
    exports.newDefinition = newDefinition;
    exports.numValue = numValue;
    exports.objValue = objValue;
    exports.register = register;
    exports.strValue = strValue;

}));
